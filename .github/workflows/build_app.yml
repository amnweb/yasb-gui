name: Build and Release

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'prerelease'
        type: choice
        options:
          - prerelease
          - stable
  repository_dispatch:
    types: [signing-complete]

permissions:
  contents: read

env:
  PYTHON_VERSION: '3.14'

jobs:
  build-exe:
    if: github.event_name == 'workflow_dispatch'
    permissions:
      contents: write
      actions: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x64
            runner: windows-latest
            artifact_suffix: x64
          - arch: arm64
            runner: windows-11-arm
            artifact_suffix: aarch64

    runs-on: ${{ matrix.runner }}
    outputs:
      run_id: ${{ github.run_id }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m venv venv
          .\venv\Scripts\Activate
          pip install --upgrade pip
          pip install .[build] --no-cache
        shell: pwsh

      - name: Build EXE
        run: |
          .\venv\Scripts\Activate
          python app/scripts/build.py build
        shell: pwsh

      - name: Upload unsigned EXE
        uses: actions/upload-artifact@v4
        with:
          name: unsigned-exe-${{ matrix.artifact_suffix }}
          path: dist/ygui.exe

  create-release:
    needs: build-exe
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      release_id: ${{ steps.create.outputs.release_id }}
      tag: ${{ steps.create.outputs.tag }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create draft release
        id: create
        uses: actions/github-script@v7
        env:
          RELEASE_TYPE: ${{ inputs.release_type }}
        with:
          github-token: ${{ secrets.YGUI_TOKEN }}
          script: |
            const fs = require('fs');
            const releaseType = process.env.RELEASE_TYPE;
            const isPrerelease = releaseType === 'prerelease';
            
            // Read version from constants.py
            const content = fs.readFileSync('app/core/constants.py', 'utf8');
            const match = content.match(/APP_VERSION\s*=\s*"([^"]+)"/);
            const version = match ? match[1] : '0.0.0';
            
            const tag = isPrerelease ? 'dev' : `v${version}`;
            const releaseName = isPrerelease 
              ? `YASB GUI Dev Build (${version})` 
              : `YASB GUI v${version}`;
            
            console.log(`Version: ${version}`);
            console.log(`Tag: ${tag}`);
            console.log(`Release type: ${releaseType}`);
            
            let release;
            try {
              // Check if release already exists (e.g., re-run)
              const { data: existing } = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tag
              });
              release = existing;
              console.log(`Found existing release: ${release.id}`);
              
              // Update the body to indicate new build
              await github.rest.repos.updateRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.id,
                body: '**Build in progress...**\n\nSigning MSIX installers...'
              });
            } catch (e) {
              // Create new release
              const { data: created } = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: tag,
                name: releaseName,
                body: '**Build in progress...**\n\nSigning MSIX installers...',
                draft: true,
                prerelease: isPrerelease
              });
              release = created;
              console.log(`Created new release: ${release.id}`);
            }
            
            core.setOutput('release_id', release.id);
            core.setOutput('version', version);
            core.setOutput('tag', tag);

  request-exe-signing:
    needs: [build-exe, create-release]
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - artifact_suffix: x64
          - artifact_suffix: aarch64

    steps:
      - name: Trigger EXE signing on yasb
        uses: actions/github-script@v7
        env:
          ARTIFACT_SUFFIX: ${{ matrix.artifact_suffix }}
          RELEASE_ID: ${{ needs.create-release.outputs.release_id }}
          TAG: ${{ needs.create-release.outputs.tag }}
          RELEASE_TYPE: ${{ inputs.release_type }}
        with:
          github-token: ${{ secrets.YGUI_TOKEN }}
          script: |
            const suffix = process.env.ARTIFACT_SUFFIX;
            const releaseId = parseInt(process.env.RELEASE_ID);
            const tag = process.env.TAG;
            const releaseType = process.env.RELEASE_TYPE;
            
            console.log(`Requesting EXE signing for ${suffix}...`);
            console.log(`Release ID: ${releaseId}, Tag: ${tag}`);
            
            // GitHub limits client_payload to 10 properties max
            await github.rest.repos.createDispatchEvent({
              owner: 'amnweb',
              repo: 'yasb',
              event_type: 'sign-external',
              client_payload: {
                source_repo: 'amnweb/yasb-gui',
                run_id: context.runId,
                signing_policy: 'release-signing-gui',
                artifact_configuration: 'release-signing-gui',
                files: ['ygui.exe'],
                mode: 'artifact',
                input_artifact_name: `unsigned-exe-${suffix}`,
                output_artifact_name: `signed-exe-${suffix}`,
                callback_stage: `exe-${suffix}`,
                callback_data: JSON.stringify({ release_id: releaseId, release_tag: tag, release_type: releaseType })
              }
            });

  build-msix:
    if: >-
      github.event_name == 'repository_dispatch' && 
      github.event.client_payload.status == 'success' &&
      startsWith(github.event.client_payload.stage, 'exe-')
    runs-on: ${{ contains(github.event.client_payload.stage, 'x64') && 'windows-latest' || 'windows-11-arm' }}
    permissions:
      contents: write
      actions: write

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Determine architecture
        id: arch
        run: |
          $stage = '${{ github.event.client_payload.stage }}'
          if ($stage -match 'x64') {
            echo "SUFFIX=x64" >> $env:GITHUB_OUTPUT
            echo "MSIX_ARCH=x64" >> $env:GITHUB_OUTPUT
          } else {
            echo "SUFFIX=aarch64" >> $env:GITHUB_OUTPUT
            echo "MSIX_ARCH=aarch64" >> $env:GITHUB_OUTPUT
          }
        shell: pwsh

      - name: Download signed EXE from yasb
        uses: actions/github-script@v7
        env:
          YASB_RUN_ID: ${{ github.event.client_payload.yasb_run_id }}
          OUTPUT_ARTIFACT: ${{ github.event.client_payload.output_artifact_name }}
        with:
          github-token: ${{ secrets.YGUI_TOKEN }}
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            const runId = parseInt(process.env.YASB_RUN_ID);
            const artifactName = process.env.OUTPUT_ARTIFACT;
            
            console.log(`Downloading ${artifactName} from yasb run ${runId}`);
            
            const { data: artifacts } = await github.rest.actions.listWorkflowRunArtifacts({
              owner: 'amnweb',
              repo: 'yasb',
              run_id: runId
            });
            
            const artifact = artifacts.artifacts.find(a => a.name === artifactName);
            if (!artifact) {
              throw new Error(`Artifact ${artifactName} not found in yasb run`);
            }
            
            const { data: download } = await github.rest.actions.downloadArtifact({
              owner: 'amnweb',
              repo: 'yasb',
              artifact_id: artifact.id,
              archive_format: 'zip'
            });
            
            fs.mkdirSync('signed-exe', { recursive: true });
            fs.writeFileSync('signed.zip', Buffer.from(download));
            execSync('powershell -Command "Expand-Archive -Path signed.zip -DestinationPath signed-exe -Force"');
            
            console.log('Signed EXE downloaded');
            const files = fs.readdirSync('signed-exe');
            console.log('Files:', files);

      - name: Install dependencies
        run: |
          python -m venv venv
          .\venv\Scripts\Activate
          pip install --upgrade pip
          pip install .[build] --no-cache
        shell: pwsh

      - name: Build EXE (to get full dist structure)
        run: |
          .\venv\Scripts\Activate
          python app/scripts/build.py build
        shell: pwsh

      - name: Replace unsigned EXE with signed
        run: |
          Write-Host "Replacing unsigned EXE with signed version..."
          Copy-Item -Path "signed-exe/ygui.exe" -Destination "dist/ygui.exe" -Force
          Write-Host "Signed EXE in place"
          Get-ChildItem dist/*.exe | ForEach-Object { 
            Write-Host "  $($_.Name) - $([math]::Round($_.Length/1MB, 2)) MB"
          }
        shell: pwsh

      - name: Build MSIX with signed EXE
        run: |
          .\venv\Scripts\Activate
          python app/scripts/build_msix.py --arch ${{ steps.arch.outputs.MSIX_ARCH }}
        shell: pwsh

      - name: Get version and MSIX filename
        id: info
        run: |
          $content = Get-Content -Path "app/core/constants.py" -Raw
          $version = [regex]::Match($content, 'APP_VERSION\s*=\s*"([^"]+)"').Groups[1].Value
          $suffix = "${{ steps.arch.outputs.SUFFIX }}"
          $msixArch = "${{ steps.arch.outputs.MSIX_ARCH }}"
          $msixName = "yasb-gui-${version}-${msixArch}.msix"
          
          echo "VERSION=$version" >> $env:GITHUB_OUTPUT
          echo "MSIX_NAME=$msixName" >> $env:GITHUB_OUTPUT
          echo "SUFFIX=$suffix" >> $env:GITHUB_OUTPUT
          
          Write-Host "Version: $version"
          Write-Host "MSIX: $msixName"
        shell: pwsh

      - name: Upload unsigned MSIX
        uses: actions/upload-artifact@v4
        with:
          name: unsigned-msix-${{ steps.arch.outputs.SUFFIX }}
          path: msix/*.msix

      - name: Upload MSIX to release
        id: release
        uses: actions/github-script@v7
        env:
          VERSION: ${{ steps.info.outputs.VERSION }}
        with:
          github-token: ${{ secrets.YGUI_TOKEN }}
          script: |
            const fs = require('fs');
            const version = process.env.VERSION;
            
            console.log(`Looking for release with version: ${version}`);
            
            // Try to find the release - could be 'dev' tag (prerelease) or 'v{version}' (stable)
            let release;
            let releaseTag;
            
            // First try 'dev' tag (prerelease)
            try {
              const { data: devRelease } = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: 'dev'
              });
              // Check if this is a draft (our in-progress release)
              if (devRelease.draft) {
                release = devRelease;
                releaseTag = 'dev';
                console.log(`Found dev release: ${release.id}`);
              }
            } catch (e) {
              console.log('No dev release found');
            }
            
            // If not found, try versioned tag
            if (!release) {
              try {
                const { data: versionedRelease } = await github.rest.repos.getReleaseByTag({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag: `v${version}`
                });
                release = versionedRelease;
                releaseTag = `v${version}`;
                console.log(`Found versioned release: ${release.id}`);
              } catch (e) {
                console.log('No versioned release found');
              }
            }
            
            if (!release) {
              throw new Error(`No release found for version ${version}`);
            }
            
            const releaseType = releaseTag === 'dev' ? 'prerelease' : 'stable';
            
            console.log(`Using release ID: ${release.id}`);
            console.log(`Release type: ${releaseType}`);
            console.log(`Release tag: ${releaseTag}`);
            console.log(`Release: ${release.name}`);
            
            const msixFiles = fs.readdirSync('msix').filter(f => f.endsWith('.msix'));
            for (const msix of msixFiles) {
              const data = fs.readFileSync(`msix/${msix}`);
              console.log(`Uploading ${msix}...`);
              
              const existingAsset = release.assets?.find(a => a.name === msix);
              if (existingAsset) {
                console.log(`Deleting existing asset: ${msix}`);
                await github.rest.repos.deleteReleaseAsset({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  asset_id: existingAsset.id
                });
              }
              
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.id,
                name: msix,
                data: data
              });
              console.log(`Uploaded: ${msix}`);
            }
            
            core.setOutput('release_id', release.id);
            core.setOutput('release_type', releaseType);
            core.setOutput('release_tag', releaseTag);

      - name: Trigger MSIX signing on yasb
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ steps.release.outputs.release_id }}
          MSIX_NAME: ${{ steps.info.outputs.MSIX_NAME }}
          SUFFIX: ${{ steps.info.outputs.SUFFIX }}
          RELEASE_TYPE: ${{ steps.release.outputs.release_type }}
          RELEASE_TAG: ${{ steps.release.outputs.release_tag }}
        with:
          github-token: ${{ secrets.YGUI_TOKEN }}
          script: |
            console.log('Requesting MSIX signing...');
            console.log(`Release ID: ${process.env.RELEASE_ID}`);
            console.log(`Release tag: ${process.env.RELEASE_TAG}`);
            console.log(`MSIX: ${process.env.MSIX_NAME}`);
            
            await github.rest.repos.createDispatchEvent({
              owner: 'amnweb',
              repo: 'yasb',
              event_type: 'sign-external',
              client_payload: {
                source_repo: 'amnweb/yasb-gui',
                release_id: parseInt(process.env.RELEASE_ID),
                release_tag: process.env.RELEASE_TAG,
                signing_policy: 'release-signing',
                artifact_configuration: 'signing_installer_msix',
                files: [process.env.MSIX_NAME],
                mode: 'release',
                callback_stage: `msix-${process.env.SUFFIX}`,
                release_type: process.env.RELEASE_TYPE
              }
            });

  finalize-release:
    if: >-
      github.event_name == 'repository_dispatch' && 
      github.event.client_payload.status == 'success' &&
      startsWith(github.event.client_payload.stage, 'msix-')
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if all MSIXs are signed
        id: check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.YGUI_TOKEN }}
          script: |
            const fs = require('fs');
            
            // Read version from constants.py
            const content = fs.readFileSync('app/core/constants.py', 'utf8');
            const match = content.match(/APP_VERSION\s*=\s*"([^"]+)"/);
            const version = match ? match[1] : '0.0.0';
            
            console.log(`Looking for release with version: ${version}`);
            
            // Try to find the release - could be 'dev' tag or 'v{version}'
            let release;
            let releaseTag;
            
            try {
              const { data: devRelease } = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: 'dev'
              });
              if (devRelease.draft) {
                release = devRelease;
                releaseTag = 'dev';
                console.log(`Found dev release: ${release.id}`);
              }
            } catch (e) {
              console.log('No dev release found');
            }
            
            if (!release) {
              try {
                const { data: versionedRelease } = await github.rest.repos.getReleaseByTag({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag: `v${version}`
                });
                release = versionedRelease;
                releaseTag = `v${version}`;
                console.log(`Found versioned release: ${release.id}`);
              } catch (e) {
                console.log('No versioned release found');
              }
            }
            
            if (!release) {
              throw new Error(`No release found for version ${version}`);
            }
            
            console.log(`Release: ${release.name} (${releaseTag})`);
            console.log(`Total assets: ${release.assets.length}`);
            release.assets.forEach(a => console.log(`  - ${a.name} (${a.size} bytes)`));
            
            const msixFiles = release.assets.filter(a => a.name.endsWith('.msix'));
            console.log(`Found ${msixFiles.length} MSIX files in release`);
            msixFiles.forEach(a => console.log(`  MSIX: ${a.name}`));
            
            // We expect 2 MSIXs (x64 and aarch64)
            const ready = msixFiles.length >= 2;
            console.log(`Ready to finalize: ${ready}`);
            
            core.setOutput('ready', ready);
            core.setOutput('release_id', release.id);
            core.setOutput('release_tag', releaseTag);
            
            return ready;

      - name: Generate checksums
        if: steps.check.outputs.ready == 'true'
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ steps.check.outputs.release_id }}
        with:
          github-token: ${{ secrets.YGUI_TOKEN }}
          script: |
            const fs = require('fs');
            const crypto = require('crypto');
            
            const releaseId = parseInt(process.env.RELEASE_ID);
            
            const { data: release } = await github.rest.repos.getRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId
            });
            
            fs.mkdirSync('dist', { recursive: true });
            let checksums = '';
            
            for (const asset of release.assets.filter(a => a.name.endsWith('.msix'))) {
              console.log(`Downloading ${asset.name} for checksum...`);
              
              const { data } = await github.rest.repos.getReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                asset_id: asset.id,
                headers: { accept: 'application/octet-stream' }
              });
              
              const hash = crypto.createHash('sha256').update(Buffer.from(data)).digest('hex');
              checksums += `${hash}  ${asset.name}\n`;
              console.log(`${asset.name}: ${hash}`);
            }
            
            fs.writeFileSync('dist/checksums.txt', checksums);
            
            const existingChecksum = release.assets.find(a => a.name === 'checksums.txt');
            if (existingChecksum) {
              console.log('Deleting existing checksums.txt...');
              await github.rest.repos.deleteReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                asset_id: existingChecksum.id
              });
            }
            
            await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              name: 'checksums.txt',
              data: fs.readFileSync('dist/checksums.txt')
            });

      - name: Generate changelog
        if: steps.check.outputs.ready == 'true'
        id: changelog
        run: |
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$PREVIOUS_TAG" ]; then
            COMMITS=$(git log --pretty=format:"- %s ([%h](https://github.com/${{ github.repository }}/commit/%H))" --no-merges)
          else
            COMMITS=$(git log "$PREVIOUS_TAG..HEAD" --pretty=format:"- %s ([%h](https://github.com/${{ github.repository }}/commit/%H))" --no-merges)
          fi
          
          echo "## What's Changed" > CHANGELOG.md
          echo "" >> CHANGELOG.md
          echo "$COMMITS" >> CHANGELOG.md
          echo "" >> CHANGELOG.md
          echo "---" >> CHANGELOG.md

      - name: Publish release
        if: steps.check.outputs.ready == 'true'
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ steps.check.outputs.release_id }}
        with:
          github-token: ${{ secrets.YGUI_TOKEN }}
          script: |
            const fs = require('fs');
            const releaseId = parseInt(process.env.RELEASE_ID);
            const changelog = fs.readFileSync('CHANGELOG.md', 'utf8');
            
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              body: changelog,
              draft: true
            });

      - name: Cleanup artifacts
        if: always()
        uses: geekyeggo/delete-artifact@v5
        with:
          name: |
            unsigned-*
            signed-*
          failOnError: false

  handle-failure:
    if: >-
      github.event_name == 'repository_dispatch' && 
      github.event.client_payload.status == 'failed'
    runs-on: ubuntu-latest

    steps:
      - name: Report failure
        run: |
          echo "Signing failed at stage: ${{ github.event.client_payload.stage }}"
          echo "Check: ${{ github.event.client_payload.run_url }}"
          exit 1
