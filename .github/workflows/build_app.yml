name: Build and Release

on:
  workflow_dispatch:
  repository_dispatch:
    types: [signing-complete]

permissions:
  contents: read

env:
  PYTHON_VERSION: '3.14'
  APP_ID: 'YASB.GUI_wbnnev551gwxy'

jobs:
  # ===========================================
  # PHASE 1: Build (triggered by workflow_dispatch)
  # ===========================================
  build:
    if: github.event_name == 'workflow_dispatch'
    permissions:
      contents: write
      actions: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x64
            runner: windows-latest
            suffix: x64
          - arch: arm64
            runner: windows-11-arm
            suffix: aarch64

    runs-on: ${{ matrix.runner }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m venv venv
          .\venv\Scripts\Activate
          pip install --upgrade pip
          pip install .[build] --no-cache
        shell: pwsh

      - name: Build application
        run: |
          .\venv\Scripts\Activate
          python app/scripts/build.py build
        shell: pwsh

      - name: Upload dist
        uses: actions/upload-artifact@v4
        with:
          name: dist-${{ matrix.suffix }}
          path: dist/

  create-release:
    needs: build
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      release_id: ${{ steps.create.outputs.release_id }}
      tag: ${{ steps.create.outputs.tag }}
      version: ${{ steps.create.outputs.version }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create draft release
        id: create
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.YGUI_TOKEN }}
          script: |
            const fs = require('fs');
            
            const content = fs.readFileSync('app/core/constants.py', 'utf8');
            const match = content.match(/APP_VERSION\s*=\s*"([^"]+)"/);
            const version = match ? match[1] : '0.0.0';
            
            const tag = `v${version}`;
            const releaseName = `YASB GUI v${version}`;
            
            console.log(`Version: ${version}, Tag: ${tag}`);
            
            // Delete existing draft release/tag if needed
            const { data: releases } = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 20
            });
            
            const existing = releases.find(r => r.tag_name === tag);
            if (existing) {
              if (!existing.draft) {
                throw new Error(`Release ${tag} already published! Bump version first.`);
              }
              await github.rest.repos.deleteRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: existing.id
              });
            }
            
            try {
              await github.rest.git.deleteRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `tags/${tag}`
              });
            } catch (e) { }
            
            const { data: ref } = await github.rest.git.getRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `heads/${context.ref.replace('refs/heads/', '')}`
            });
            
            await github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `refs/tags/${tag}`,
              sha: ref.object.sha
            });
            
            const { data: release } = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tag,
              name: releaseName,
              body: '**Build in progress...**\n\nSigning packages...',
              draft: true
            });
            
            core.setOutput('release_id', release.id);
            core.setOutput('tag', tag);
            core.setOutput('version', version);

  request-signing:
    needs: [build, create-release]
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        suffix: [x64, aarch64]

    steps:
      - name: Request EXE signing
        uses: actions/github-script@v7
        env:
          SUFFIX: ${{ matrix.suffix }}
          RELEASE_ID: ${{ needs.create-release.outputs.release_id }}
          RELEASE_TAG: ${{ needs.create-release.outputs.tag }}
          VERSION: ${{ needs.create-release.outputs.version }}
        with:
          github-token: ${{ secrets.YGUI_TOKEN }}
          script: |
            const suffix = process.env.SUFFIX;
            console.log(`Requesting signing for ${suffix}...`);
            
            await github.rest.repos.createDispatchEvent({
              owner: 'amnweb',
              repo: 'yasb',
              event_type: 'sign-external',
              client_payload: {
                source_repo: 'amnweb/yasb-gui',
                run_id: context.runId,
                signing_policy: 'release-signing-gui',
                artifact_configuration: 'release-signing-gui',
                files: ['ygui.exe'],
                mode: 'artifact',
                input_artifact_name: `dist-${suffix}`,
                output_artifact_name: `signed-dist-${suffix}`,
                callback_stage: `exe-${suffix}`,
                release_id: parseInt(process.env.RELEASE_ID),
                release_tag: process.env.RELEASE_TAG,
                version: process.env.VERSION
              }
            });

  # ===========================================
  # PHASE 2: Package signed EXE (triggered by SignPath callback)
  # ===========================================
  package-signed:
    if: >-
      github.event_name == 'repository_dispatch' && 
      github.event.client_payload.status == 'success' &&
      startsWith(github.event.client_payload.stage, 'exe-')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write

    steps:
      - name: Determine architecture and version
        id: info
        uses: actions/github-script@v7
        env:
          STAGE: ${{ github.event.client_payload.stage }}
          RELEASE_ID: ${{ github.event.client_payload.release_id }}
        with:
          github-token: ${{ secrets.YGUI_TOKEN }}
          script: |
            const stage = process.env.STAGE;
            const releaseId = parseInt(process.env.RELEASE_ID);
            
            // Get release to extract tag
            const { data: release } = await github.rest.repos.getRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId
            });
            
            const version = release.tag_name.replace(/^v/, '');
            const suffix = stage === 'exe-x64' ? 'x64' : 'aarch64';
            
            core.setOutput('VERSION', version);
            core.setOutput('SUFFIX', suffix);
            core.setOutput('RELEASE_TAG', release.tag_name);
            
            console.log(`Version: ${version}, Suffix: ${suffix}, Tag: ${release.tag_name}`);

      - name: Download signed dist from yasb
        uses: actions/github-script@v7
        env:
          YASB_RUN_ID: ${{ github.event.client_payload.yasb_run_id }}
          SUFFIX: ${{ steps.info.outputs.SUFFIX }}
        with:
          github-token: ${{ secrets.YGUI_TOKEN }}
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            const suffix = process.env.SUFFIX;
            const runId = parseInt(process.env.YASB_RUN_ID);
            
            const { data: artifacts } = await github.rest.actions.listWorkflowRunArtifacts({
              owner: 'amnweb',
              repo: 'yasb',
              run_id: runId
            });
            
            const artifact = artifacts.artifacts.find(a => a.name === `signed-dist-${suffix}`);
            if (!artifact) throw new Error(`Artifact signed-dist-${suffix} not found`);
            
            const { data: download } = await github.rest.actions.downloadArtifact({
              owner: 'amnweb',
              repo: 'yasb',
              artifact_id: artifact.id,
              archive_format: 'zip'
            });
            
            fs.mkdirSync('signed-dist', { recursive: true });
            fs.writeFileSync('signed.zip', Buffer.from(download));
            execSync('unzip -o signed.zip -d signed-dist');

      - name: Create portable package
        env:
          VERSION: ${{ steps.info.outputs.VERSION }}
          SUFFIX: ${{ steps.info.outputs.SUFFIX }}
        run: |
          cd signed-dist
          zip -r "../YASB.GUI_${VERSION}_${SUFFIX}.zip" .
          ls -la ../

      - name: Upload portable to release
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ github.event.client_payload.release_id }}
          VERSION: ${{ steps.info.outputs.VERSION }}
          SUFFIX: ${{ steps.info.outputs.SUFFIX }}
        with:
          github-token: ${{ secrets.YGUI_TOKEN }}
          script: |
            const fs = require('fs');
            const releaseId = parseInt(process.env.RELEASE_ID);
            const version = process.env.VERSION;
            const suffix = process.env.SUFFIX;
            const filename = `YASB.GUI_${version}_${suffix}.zip`;
            
            const { data: release } = await github.rest.repos.getRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId
            });
            
            const existing = release.assets.find(a => a.name === filename);
            if (existing) {
              await github.rest.repos.deleteReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                asset_id: existing.id
              });
            }
            
            await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              name: filename,
              data: fs.readFileSync(filename)
            });
            
            console.log(`Uploaded: ${filename}`);

      - name: Check if ready for bundle
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ github.event.client_payload.release_id }}
          RELEASE_TAG: ${{ steps.info.outputs.RELEASE_TAG }}
          VERSION: ${{ steps.info.outputs.VERSION }}
        with:
          github-token: ${{ secrets.YGUI_TOKEN }}
          script: |
            const releaseId = parseInt(process.env.RELEASE_ID);
            
            const { data: release } = await github.rest.repos.getRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId
            });
            
            const portables = release.assets.filter(a => a.name.startsWith('YASB.GUI_') && a.name.endsWith('.zip'));
            console.log(`Portable packages uploaded: ${portables.length}/2`);
            portables.forEach(a => console.log(`  - ${a.name}`));
            
            if (portables.length >= 2) {
              console.log('Both portables ready, triggering bundle build...');
              
              await github.rest.repos.createDispatchEvent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                event_type: 'signing-complete',
                client_payload: {
                  status: 'success',
                  stage: 'portables-ready',
                  release_id: releaseId,
                  release_tag: process.env.RELEASE_TAG,
                  version: process.env.VERSION
                }
              });
            }

  # ===========================================
  # PHASE 3: Build bundle (triggered when both portables ready)
  # ===========================================
  build-bundle:
    if: >-
      github.event_name == 'repository_dispatch' && 
      github.event.client_payload.status == 'success' &&
      github.event.client_payload.stage == 'portables-ready'
    runs-on: windows-latest
    permissions:
      contents: write
      actions: write

    steps:
      - name: Extract version from tag
        id: info
        run: |
          $tag = "${{ github.event.client_payload.release_tag }}"
          $version = $tag -replace '^v', ''
          echo "VERSION=$version" >> $env:GITHUB_OUTPUT
          Write-Host "Version: $version"
        shell: pwsh

      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Download portable packages from release
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ github.event.client_payload.release_id }}
          VERSION: ${{ steps.info.outputs.VERSION }}
        with:
          github-token: ${{ secrets.YGUI_TOKEN }}
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            const releaseId = parseInt(process.env.RELEASE_ID);
            const version = process.env.VERSION;
            
            const { data: release } = await github.rest.repos.getRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId
            });
            
            fs.mkdirSync('signed-dists', { recursive: true });
            
            for (const suffix of ['x64', 'aarch64']) {
              const filename = `YASB.GUI_${version}_${suffix}.zip`;
              const asset = release.assets.find(a => a.name === filename);
              if (!asset) throw new Error(`Asset ${filename} not found`);
              
              console.log(`Downloading ${filename}...`);
              
              const { url } = await github.rest.repos.getReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                asset_id: asset.id,
                headers: { accept: 'application/octet-stream' }
              });
              
              const response = await fetch(url);
              const buffer = Buffer.from(await response.arrayBuffer());
              fs.writeFileSync(filename, buffer);
              
              // Extract to signed-dists/signed-dist-{suffix}
              const extractDir = `signed-dists/signed-dist-${suffix}`;
              fs.mkdirSync(extractDir, { recursive: true });
              execSync(`powershell -Command "Expand-Archive -Path '${filename}' -DestinationPath '${extractDir}' -Force"`);
              
              console.log(`Extracted to ${extractDir}`);
            }

      - name: Install dependencies
        run: |
          python -m venv venv
          .\venv\Scripts\Activate
          pip install --upgrade pip
          pip install .[build] --no-cache
        shell: pwsh

      - name: Build MSIX for x64
        run: |
          .\venv\Scripts\Activate
          
          # Copy signed dist to expected location
          if (Test-Path dist) { Remove-Item -Recurse -Force dist }
          Copy-Item -Recurse signed-dists/signed-dist-x64 dist
          
          # Build MSIX
          python app/scripts/build_msix.py --arch x64
          
          # Move to temp location
          New-Item -ItemType Directory -Path msix-all -Force
          Move-Item msix/*.msix msix-all/
        shell: pwsh

      - name: Build MSIX for arm64
        run: |
          .\venv\Scripts\Activate
          
          # Copy signed dist
          if (Test-Path dist) { Remove-Item -Recurse -Force dist }
          Copy-Item -Recurse signed-dists/signed-dist-aarch64 dist
          
          # Build MSIX
          python app/scripts/build_msix.py --arch aarch64
          
          # Move to combined location
          Move-Item msix/*.msix msix-all/
        shell: pwsh

      - name: Create MSIX bundle
        run: |
          .\venv\Scripts\Activate
          
          # Move MSIXs to expected location
          if (Test-Path msix) { Remove-Item -Recurse -Force msix }
          Rename-Item msix-all msix
          
          # Create bundle
          $msixFiles = Get-ChildItem msix/*.msix | ForEach-Object { $_.FullName }
          python app/scripts/build_msix.py --bundle --msix-files $msixFiles
          
          Write-Host "Bundle created:"
          Get-ChildItem msix/*.msixbundle
        shell: pwsh

      - name: Upload bundle to release
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ github.event.client_payload.release_id }}
          VERSION: ${{ steps.info.outputs.VERSION }}
          APP_ID: ${{ env.APP_ID }}
        with:
          github-token: ${{ secrets.YGUI_TOKEN }}
          script: |
            const fs = require('fs');
            const releaseId = parseInt(process.env.RELEASE_ID);
            const version = process.env.VERSION;
            const appId = process.env.APP_ID;
            const publisherId = appId.split('_')[1];
            const bundleName = `YASB.GUI_${version}_${publisherId}.msixbundle`;
            
            const { data: release } = await github.rest.repos.getRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId
            });
            
            const existing = release.assets.find(a => a.name === bundleName);
            if (existing) {
              await github.rest.repos.deleteReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                asset_id: existing.id
              });
            }
            
            await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              name: bundleName,
              data: fs.readFileSync(`msix/${bundleName}`)
            });
            
            console.log(`Uploaded: ${bundleName}`);

      - name: Request bundle signing
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ github.event.client_payload.release_id }}
          RELEASE_TAG: ${{ github.event.client_payload.release_tag }}
          VERSION: ${{ steps.info.outputs.VERSION }}
          APP_ID: ${{ env.APP_ID }}
        with:
          github-token: ${{ secrets.YGUI_TOKEN }}
          script: |
            const version = process.env.VERSION;
            const releaseTag = process.env.RELEASE_TAG;
            const appId = process.env.APP_ID;
            const publisherId = appId.split('_')[1];
            const bundleName = `YASB.GUI_${version}_${publisherId}.msixbundle`;
            
            console.log(`Requesting bundle signing: ${bundleName}`);
            
            await github.rest.repos.createDispatchEvent({
              owner: 'amnweb',
              repo: 'yasb',
              event_type: 'sign-external',
              client_payload: {
                source_repo: 'amnweb/yasb-gui',
                release_id: parseInt(process.env.RELEASE_ID),
                release_tag: releaseTag,
                signing_policy: 'release-signing',
                artifact_configuration: 'signing_installer_msix',
                files: [bundleName],
                mode: 'release',
                callback_stage: 'bundle',
                version: version
              }
            });

  # ===========================================
  # PHASE 4: Publish release (triggered after bundle signed)
  # ===========================================
  publish-release:
    if: >-
      github.event_name == 'repository_dispatch' && 
      github.event.client_payload.status == 'success' &&
      github.event.client_payload.stage == 'bundle'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate changelog
        env:
          RELEASE_TAG: ${{ github.event.client_payload.release_tag }}
        run: |
          # Find previous stable tag (exclude current)
          previousTag=$(git tag -l --sort=-v:refname | grep -E "^v[0-9]+\.[0-9]+\.[0-9]+" | grep -v "^${RELEASE_TAG}$" | head -n 1 || true)
          
          if [ -n "$previousTag" ]; then
            commits=$(git log "$previousTag..HEAD" --pretty=format:"* %s %h" --no-merges)
          else
            commits=$(git log -n 20 --pretty=format:"* %s %h" --no-merges)
          fi
          
          [ -z "$commits" ] && commits="* No significant changes"
          printf '%s\n' "$commits" > CHANGELOG.md

      - name: Generate checksums and publish
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ github.event.client_payload.release_id }}
        with:
          github-token: ${{ secrets.YGUI_TOKEN }}
          script: |
            const fs = require('fs');
            const crypto = require('crypto');
            const releaseId = parseInt(process.env.RELEASE_ID);
            const changelog = fs.readFileSync('CHANGELOG.md', 'utf8');
            
            const { data: release } = await github.rest.repos.getRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId
            });
            
            // Generate checksums for all assets
            let checksums = '';
            for (const asset of release.assets.filter(a => 
              a.name.endsWith('.msixbundle') || (a.name.startsWith('YASB.GUI_') && a.name.endsWith('.zip'))
            )) {
              console.log(`Generating checksum for ${asset.name}...`);
              
              const { data } = await github.rest.repos.getReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                asset_id: asset.id,
                headers: { accept: 'application/octet-stream' }
              });
              
              const hash = crypto.createHash('sha256').update(Buffer.from(data)).digest('hex');
              checksums += `${hash}  ${asset.name}\n`;
            }
            
            // Upload checksums
            const existingChecksum = release.assets.find(a => a.name === 'checksums.txt');
            if (existingChecksum) {
              await github.rest.repos.deleteReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                asset_id: existingChecksum.id
              });
            }
            
            await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              name: 'checksums.txt',
              data: Buffer.from(checksums)
            });
            
            // Update release with changelog (keep as draft for manual publish)
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              body: changelog,
              draft: true
            });
            
            console.log('Release ready for publishing!');

      - name: Cleanup artifacts
        if: always()
        uses: geekyeggo/delete-artifact@v5
        with:
          name: dist-*
          failOnError: false

  # ===========================================
  # Handle signing failures
  # ===========================================
  handle-failure:
    if: >-
      github.event_name == 'repository_dispatch' && 
      github.event.client_payload.status == 'failed'
    runs-on: ubuntu-latest

    steps:
      - name: Report failure
        run: |
          echo "::error::Signing failed at stage: ${{ github.event.client_payload.stage }}"
          echo "Check: ${{ github.event.client_payload.run_url }}"
          exit 1
